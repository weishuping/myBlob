[TOC]

## 面试知识点总结

### HTML+CSS相关

#### 1. 三列布局/两列布局

- [http://www.ryanshang.com/2018/01/20/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/](http://www.ryanshang.com/2018/01/20/三栏布局/)

#### 2. ul中插入上万个li如何操作？如何给所有li绑定事件获取当前li索引？

- 文档碎片
- 二分查找

#### 3. 水平垂直居中，不定宽高。

- [http://www.ryanshang.com/2018/04/15/CSS垂直居中/](http://www.ryanshang.com/2018/04/15/CSS垂直居中/)

#### 4. 移动端按钮文字上下不居中如何处理

- 方案1

我们可以通过 transform: scale 来处理，比如，字体大小是 8px，我们把字体设定为 16px，然后通过 scale(0.5) 缩放至一倍大小，简单粗暴。

注意：放大两倍会使得容器被撑开占位。

- 方案2：

结合行高、对齐的关系，结合伪元素得出的黑科技，亲测效果很理想。

```
.jd::before {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 0;
    height: 100%;
    margin-top: 1px;
}
```

#### 5. CSS单行截断和多行截断

- 单行

```css
#p1 {
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}
```

- 多行

```css
/* webkit-box */
#p2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  text-overflow: ellipsis;
  overflow: hidden;
}
/* 伪元素 */
#p3 {
  overflow: hidden;
  position: relative;
  height: 40px;
  line-height: 20px;
}
#p3::after {
  content: '...';
  position: absolute;
  right: 0;
  bottom: 0;
  font-weight: bold;
  padding: 0 10px 1px 45px;
  background: linear-gradient(to right, rgba(0, 0, 0, 0), aqua 50%, aqua);
}
```

#### 6. 同心圆

- [http://www.ryanshang.com/2019/05/02/两道有意思的面试题/#2-二、同心圆](http://www.ryanshang.com/2019/05/02/两道有意思的面试题/#2-二、同心圆)
  解决：首先是div+border+box-shadow.然后用伪元素也可以实现

#### 7. 伪类、伪元素

- 伪类与伪元素的区别在于：有没有创建一个文档树之外的元素 http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/

#### 8. position

https://www.w3school.com.cn/cssref/pr_class_position.asp

- 文档流，absolute、fixed和float会脱离正常文档流
- relative相对于哪里偏移？生成相对定位的元素，相对于其正常位置进行定位
- absolute的父级？生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。

#### 9. animation和transition区别

- transition  

transition 属性是一个简写属性，用于设置四个过渡属性 

transition: property duration timing-function delay;

过渡的属性、完成过度效果需要时间、速度曲线、延迟时间

```css
.one1{transition: width 3s linear 2s;}
.one1:hover{width:300px;}
```

transition定义了动画的属性、时间、速度曲线以及延迟时间；通常和hover等事件配合使用，由事件触发。

- animation  

animation 属性是一个简写属性，用于设置六个动画属性：

animation的使用必须结合@keyframes animation-name使用

```css
@keyframes move{
  form{ left:0px;}
  to{ left:200px;}
}
```

在需要动画的元素上面添加动画  div{animation:move 5s infinite;}

animation: name duration timing-function delay iteration-count direction;

动画名称、动画执行时间、速度曲线、动画延迟时间、播放次数、是否反向播放

animation可以设定每一帧的样式和时间。

- 区别：

  1. 触发条件不同。transition通常和hover等事件配合使用，由事件触发。animation则立即播放。
2. 循环。 animation可以设定循环次数。
  3. 精确性。 animation可以设定每一帧的样式和时间。tranistion 只能设定头尾。 animation中可以设置每一帧需要单独变化的样式属性， transition中所有样式属性都要一起变化。
4. 与javascript的交互。animation与js的交互不是很紧密。tranistion和js的结合更强大。js设定要变化的样式，transition负责动画效果，天作之合，比之前只能用js时爽太多。

#### 10. BFC

https://juejin.im/post/59b73d5bf265da064618731d



### JavaScript相关

#### 1. window.onload和document.onload区别

- window.onload：在页面所有资源加载完后执行

- document.onload：文档（DOM）加载完成后执行

#### 2. e.target和e.currentTarget区别

- 没有时间委托的时候一样。

- 有事件委托的时候，e.target是现在事件捕获或冒泡到的元素节点，e.currentTarget是绑定这个事件的元素节点。

#### 3. this相关

- 绑定规则：
  - 默认：绑定到window
  - 隐式：obj.a  "."前面的对象
  - 显式：call、apply、bind
  - new：绑定到实例
  - 箭头函数：沿着作用域链找到上一层的this

#### 4. 变量提升/函数提升，优先级 

- 函数提升优先级高于变量提升

#### 5. 函数执行过程

1. 开辟一个私有作用域
2. 形参赋值
3. 变量提升
4. 代码从上往下执行

#### 6. new执行过程

- 创建一个新对象
- 新对象被执行[[prototype]]连接
- 构造函数执行，传入相应参数
- this绑定到这个实例
- 如果对象没有返回其他对象，那么new表达式的函数调用会自动返回这个新对象

#### 7. Object.create返回的对象和字面量赋值获取的对象的区别？
5中方式。
Object.create的属性是原型链的属性。字面量赋值的属性是对象的私有属性；
还有new Object({name:1})这种。构造函数是Object,是私有属性。
还有 new XX()。构造函数是自己的类。
还有class 创建对象。

- [http://www.ryanshang.com/2019/04/18/你不知道的JavaScript/#5-定义Object的不同方式和区别](http://www.ryanshang.com/2019/04/18/你不知道的JavaScript/#5-定义Object的不同方式和区别)


#### 8. bind封装，pollyfill

- https://blog.csdn.net/Real_Bird/article/details/77962322
- https://blog.csdn.net/u010552788/article/details/50850453

```javascript
if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable')
    }
    var aArgs   = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          return fToBind.apply(this instanceof fNOP // 这段代码会判断硬绑定函数是否是被new调用，如果是的话就会使用新创建的this替换硬绑定的this
                 ? this
                 : oThis,
                 aArgs.concat(Array.prototype.slice.call(arguments)))
        }
    // 维护原型关系
    if (this.prototype) {
        // Function.prototype doesn't have a prototype property
        fNOP.prototype = this.prototype; 
    }
    fBound.prototype = new fNOP()
    return fBound
  }
}
```

#### 9. async/await原理

https://juejin.im/post/5dc28ea66fb9a04a881d1ac0

https://github.com/frontend9/fe9-interview/issues/6
是generator的语法糖，少了手动调用next()。
async异步函数，不阻塞后面代码的运行。返回Promise类型。
await写法更像同步写法。多级联调用。让出线程。
执行顺序：https://blog.csdn.net/baidu_33295233/article/details/79335127

#### 10. promise原理，是否一定返回一个promise对象

https://es6.ruanyifeng.com/#docs/promise

https://juejin.im/post/5d6f7c83e51d4561c541a712

- promise三种状态 pending 已完成 已拒绝。必须是三种的一种。一旦Promise被resolve或者reject，状态不会发生改变。

实现：

#### 11. strict mode
'use strict'
#### 12. fetch兼容性

https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API

#### 13. 代码实现发布订阅模式
https://www.cnblogs.com/itgezhu/p/10947405.html
```javascript
var observer = {
    //订阅
    addSubscriber: function (callback) {
        this.subscribers[this.subscribers.length] = callback;
    },
    //退订
    removeSubscriber: function (callback) {
        for (var i = 0; i < this.subscribers.length; i++) {
            if (this.subscribers[i] === callback) {
                delete (this.subscribers[i]);
            }
        }
    },
    //发布
    publish: function (what) {
        for (var i = 0; i < this.subscribers.length; i++) {
            if (typeof this.subscribers[i] === 'function') {
                this.subscribers[i](what);
            }
        }
    },
    // 将对象o具有观察者功能
    make: function (o) { 
        for (var i in this) {
            o[i] = this[i];
            o.subscribers = [];
        }
    }
};
```

#### 14. 实现`O.add(1).mins(3)`，实现`Number(O.add(1).mins(3))`

https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/88

- 每个方法返回实例
- valueOf 可以获取到数字，然后重写add min方法，Number.prototype.add = (n) => { this.valueOf + n;}

#### 15. 实现`a.b.x = 1`不报错

- object.defineProperty
- reduce处理a[b.x] 不是 a.b.x的问题

let a ={};
Object.defineProperty(a, 'b', {
    value: {c:1},
    writable: false
})

#### 16. 节流和防抖的原理和区别

- 节流

```javascript
/**
*
* @param fn {Function}   实际要执行的函数
* @param delay {Number}  执行间隔，单位是毫秒（ms）
*
* @return {Function}     返回一个“节流”函数
*/

function throttle(fn, threshhold) {
  // 记录上次执行的时间
  var last
  // 定时器
  var timer
  // 默认间隔为 250ms
  threshhold || (threshhold = 250)
  // 返回的函数，每过 threshhold 毫秒就执行一次 fn 函数
  return function () {
    // 保存函数调用时的上下文和参数，传递给 fn
    var context = this
    var args = arguments
    var now = +new Date()
    // 如果距离上次执行 fn 函数的时间小于 threshhold，那么就放弃
    // 执行 fn，并重新计时
    if (last && now < last + threshhold) {
      clearTimeout(timer)
      // 保证在当前时间区间结束后，再执行一次 fn
      timer = setTimeout(function () {
        last = now
        fn.apply(context, args)
      }, threshhold)
    // 在时间区间的最开始和到达指定间隔的时候执行一次 fn
    } else {
      last = now
      fn.apply(context, args)
    }
  }
}
```

- 防抖

```javascript
/**
 *
 * @param fn {Function}   实际要执行的函数
 * @param delay {Number}  延迟时间，单位是毫秒（ms）
 *
 * @return {Function}     返回一个“防反跳”了的函数
 */

function debounce(fn, delay) {
  // 定时器，用来 setTimeout
  var timer
  // 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数
  return function () {
    // 保存函数调用时的上下文和参数，传递给 fn
    var context = this
    var args = arguments
    // 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn
    clearTimeout(timer)
    // 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），
    // 再过 delay 毫秒就执行 fn
    timer = setTimeout(function () {
      fn.apply(context, args)
    }, delay)
  }
}
```

#### 17. 对象深克隆和浅克隆，Object.assign()是哪种拷贝

- Object.assign()浅拷贝
// todo
```javascript
/**
 * 对一个object进行深度拷贝
 *
 * @param {Object} source 需要进行拷贝的对象
 * @remark
 * 对于Object来说，只拷贝自身成员，不拷贝prototype成员
 * @meta standard
 *
 * @returns {Object} 拷贝后的新对象
 */
function clone (source) {
  var result = source
  let i
  let len
  if (!source || source instanceof Number || source instanceof String || source instanceof Boolean) {
    return result
  } else if (Array.isArray(source)) {
    result = []
    var resultLen = 0
    for (i = 0, len = source.length; i < len; i++) {
      result[resultLen++] = clone(source[i])
    }
  } else if (Object.prototype.toString.call(source) !== '[object Object]') {
    result = {}
    for (i in source) {
      if (source.hasOwnProperty(i)) {
        result[i] = clone(source[i])
      }
    }
  }
  return result
}
```

#### 18. ==比较，隐式转换

1. 对象和对象间比较引用地址
2. 对象和三种基本数据类型转换，先转换成字符串，如果需要则继续转换则数字
3. 三种基本数据类型转换成数字再进行比较
4. null和undefined和除了自身任何数比较都为false
5. NaN任何时候比较都返回false

#### 19. Object.defineProperty/Proxy/Reflect

- https://juejin.im/post/5be4f7cfe51d453339084530

- 阮一峰
- Object.defineProperty的不足。Reflect让一些属性行变成了函数行为。
- Reflect.defineProperty的返回值  -false

#### 20. 正则相关用法，replace、match、test

- 正则分组

#### 21. 闭包
可以访问函数外部变量的函数。防止内存泄露，是因为这些变量存在于内存当中。
https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html

https://zhuanlan.zhihu.com/p/29157822

#### 22. Eventlop
js是单线程。
js的运行机制：主线程运行完毕，开始运行任务队列（存放的是异步事件）。然后继续循环，这就是事件循环。
http://www.ruanyifeng.com/blog/2014/10/event-loop.html

https://juejin.im/post/5b73d7a6518825610072b42b

- 宏任务和微任务
- 执行次序

#### 23. call.call和bind.bind

- [http://www.ryanshang.com/2019/04/30/call和bind/](http://www.ryanshang.com/2019/04/30/call和bind/)
- 题外话： bind的参数可以分为多次传入。三个都是为了改变this指向。

#### 24. 设计模式

https://juejin.im/post/5c984610e51d45656702a785

- 单例
- 工厂
单例模式保证一个类仅有一个实例。

#### 25. 模块化规范

https://juejin.im/post/5aaa37c8f265da23945f365c

- AMD依赖前置、提前执行
- CMD依赖就近、延迟执行
- common.js
- ES6

#### 26. pushState

- pushState()方法是在历史记录中增加一条新的记录
- replaceState()方法是将当前的历史记录给替换掉

#### 27. JavaScript数据结构和算法

https://github.com/zoro-web/blog/issues/4

 

### Vue相关

#### 1. vue.$data为什么是function返回一个{}？

- 防止不同实例数据引用地址指向同一个对象，互相污染

#### 2. vue.sync原理

Vue提供了sync修饰符简化上面的代码，例如：

```
<comp :foo.sync="bar"></comp>
```
会被扩展为：
```
<comp :foo="bar" @update:foo="val => bar = val"></comp>
```
然后你需要在子组件中改变父组件数据的时候， 需要触发以下的自定义事件:
```
this.$emit("update:foo", newValue)
```

#### 3. 虚拟DOM
使用javascript模拟了DOM结构的树形结构.
https://juejin.im/post/5affd01551882542c83301da

https://juejin.im/post/5ad6182df265da23906c8627

- DOMdiff

#### 4. $nextTick原理

- Eventloop

#### 5. vue computed原理，和watch区别

https://zheyaoa.github.io/2019/09/07/computed/

https://segmentfault.com/a/1190000010408657

- 依赖收集
- computed多对一，watch一对多
- computed惰性

#### 6. vue的Observer、Watcher、Dep对应vue实例的哪一部分

Observer给数据添加Dep依赖。Watcher会绑定update方法。Dep：当数据发生变化，Dep会通知Watcher。
#### 7. mvvm原理
数据双向绑定。数据劫持+发布订阅者模式
https://juejin.im/post/5abdd6f6f265da23793c4458

#### 8. 双向绑定原理，vue中有哪些双向绑定的例子

https://juejin.im/entry/5923973da22b9d005893805a

- v-model
- .sync

#### 9. 自定义指令

- [https://cn.vuejs.org/v2/guide/custom-directive.html](https://cn.vuejs.org/v2/guide/custom-directive.html)

#### 10. createElement 使用

```javascript
// @returns {VNode}
createElement(
  // {String | Object | Function}
  // 一个 HTML 标签名、组件选项对象，或者
  // resolve 了上述任何一种的一个 async 函数。必填项。
  'div',

  // {Object}
  // 一个与模板中属性对应的数据对象。可选。
  {
    // (详情见下一节)
  },

  // {String | Array}
  // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，
  // 也可以使用字符串来生成“文本虚拟节点”。可选。
  [
    '先写一些文字',
    createElement('h1', '一则头条'),
    createElement(MyComponent, {
      props: {
        someProp: 'foobar'
      }
    })
  ]
)
```

```javascript
{
  // 与 `v-bind:class` 的 API 相同，
  // 接受一个字符串、对象或字符串和对象组成的数组
  'class': {
    foo: true,
    bar: false
  },
  // 与 `v-bind:style` 的 API 相同，
  // 接受一个字符串、对象，或对象组成的数组
  style: {
    color: 'red',
    fontSize: '14px'
  },
  // 普通的 HTML 特性
  attrs: {
    id: 'foo'
  },
  // 组件 prop
  props: {
    myProp: 'bar'
  },
  // DOM 属性
  domProps: {
    innerHTML: 'baz'
  },
  // 事件监听器在 `on` 属性内，
  // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。
  // 需要在处理函数中手动检查 keyCode。
  on: {
    click: this.clickHandler
  },
  // 仅用于组件，用于监听原生事件，而不是组件内部使用
  // `vm.$emit` 触发的事件。
  nativeOn: {
    click: this.nativeClickHandler
  },
  // 自定义指令。注意，你无法对 `binding` 中的 `oldValue`
  // 赋值，因为 Vue 已经自动为你进行了同步。
  directives: [
    {
      name: 'my-custom-directive',
      value: '2',
      expression: '1 + 1',
      arg: 'foo',
      modifiers: {
        bar: true
      }
    }
  ],
  // 作用域插槽的格式为
  // { name: props => VNode | Array<VNode> }
  scopedSlots: {
    default: props => createElement('span', props.text)
  },
  // 如果组件是其它组件的子组件，需为插槽指定名称
  slot: 'name-of-slot',
  // 其它特殊顶层属性
  key: 'myKey',
  ref: 'myRef',
  // 如果你在渲染函数中给多个元素都应用了相同的 ref 名，
  // 那么 `$refs.myRef` 会变成一个数组。
  refInFor: true
}
```

#### 11. vue SSR相关

- [https://ssr.vuejs.org/zh/](https://ssr.vuejs.org/zh/)

#### 12. 组件间通讯方式

https://juejin.im/post/5cde0b43f265da03867e78d3

- EventBus
- props/emit; vuex; $attrs/$listners; provide/inject(主动提供和依赖注入); $parent/$children

#### 13. this.$set

https://juejin.im/post/5d3c7dcfe51d45572c060131

在实例创建之后添加新的属性不会被更新到视图中。



### 脚手架相关

#### 1. 常用打包工具了解

- webpack：[https://juejin.im/entry/5b0e3eba5188251534379615](https://juejin.im/entry/5b0e3eba5188251534379615)
- webpack loader顺序原因style|css|less

#### 2. webpack开发/打包优化

主要思路：

1. 减少检索时间：resolve路径、路径设置别名、
2. 多进程编译压缩：happyPack
3. 减少编译内容：exclude不需要解析的模块、CommonsChunk
4. 动态链接库：DllPlugin、DllReferencePlugin
5. 缓存：webpack.cache、babel-loader.cacheDirectory、HappyPack.cache

- [http://eternalsky.me/ru-he-10-bei-ti-gao-ni-de-webpack-gou-jian-xiao-lu/](http://eternalsky.me/ru-he-10-bei-ti-gao-ni-de-webpack-gou-jian-xiao-lu/)
- [https://juejin.im/post/5abbc2ca5188257ddb0fae9b](https://juejin.im/post/5abbc2ca5188257ddb0fae9b)
- [https://juejin.im/post/5ac769e7f265da237b225490](https://juejin.im/post/5ac769e7f265da237b225490)
- [https://juejin.im/post/5ac76a8f51882555677ecc06](https://juejin.im/post/5ac76a8f51882555677ecc06)

#### 3. Vue loader作用

- 作用：将vue文件转换为js模块
- 特性：
	1. ES2015默认支持 
	2. 允许对VUE组件的组成部分使用其他webpack loader;比如对< style >使用SASS（编译CSS语言），对< template >使用JADE（jade是一个高性能的模板引擎，用JS实现，也有其他语言的实现—php,scala,yuby,python,java，可以供给node使用） 
	3. .vue文件中允许自定义节点，然后使用自定义的loader处理他们 
	4. 对< style >< template >中的静态资源当做模块来对待，并且使用webpack loaders进行处理 
	5. 对每个组件模拟出CSS作用域 
	6. 支持开发期组件的热重载 

#### 4. babel的执行过程

1. **解析**：将代码字符串解析成抽象语法树

2. **变换**：对抽象语法树进行变换操作

3. **再建**：根据变换后的抽象语法树再生成代码字符串

- [https://zhuanlan.zhihu.com/p/27289600](https://zhuanlan.zhihu.com/p/27289600)
- [https://www.cnblogs.com/lsgxeva/p/7758184.html](https://www.cnblogs.com/lsgxeva/p/7758184.html)

#### 5. babel-core、babel-runtime、babel-polyfill

#### 6. webapck常用的插件
1. 热替换
2. htmlWebpackPlugin 生成html模板， 参数有压缩模板minify属性，清除注释，清除空格换行等
3. 

### 浏览器相关

#### 1. 浏览器存储

https://www.ruanyifeng.com/blog/2018/07/indexeddb.html

- 需要了解IndexedDB

#### 2. 浏览器性能优化

- [https://www.jianshu.com/p/fe32ef31deed](https://www.jianshu.com/p/fe32ef31deed)

#### 3. 浏览器线程

- [https://segmentfault.com/a/1190000013083967](https://segmentfault.com/a/1190000013083967)

- GUI渲染线程
- JS引擎线程
- 时间触发线程
- 定时触发器线程
- 异步http请求线程 

#### 4. Tab间通信

https://juejin.im/post/5acdba01f265da23826e5633

- cookie + 轮询
- localStorage + 监听storage事件
- postMessage
- SharedWorker

#### 5. Service Worker

#### 6. Chrome的$0、$

- $0：devtool中Element页选中的元素
- $$：控制台选择器

#### 7. 浏览器devtool Performance

#### 8. 浏览器性能指标

- FP: First Paint，首次绘制，标记浏览器渲染任何在视觉上不同于导航前屏幕内容的时间点
- FCP: First Contentful Paint，首次内容绘制，标记的是浏览器渲染第一针内容 DOM 的时间点，该内容可能是文本、图像、SVG 或者 `<canvas>` 等元素
- FMP: First Meaningful Paint，首次有效绘制，标记主角元素渲染完成的时间点，主角元素可以是视频网站的视频控件，内容网站的页面框架也可以是资源网站的头图等
- TTI: Time to Interactive



### 通信相关

#### 1. HTTPS相关

https://juejin.im/post/59e4c02151882578d02f4aca

#### 2. 跨域的方式

https://juejin.im/post/5a2f92c65188253e2470f16d

- jsonp
- CORS
- websocket
- hash
- postMessage

#### 3. Promise版ajax

#### 4. jsonp手写
jsonp的核心原理就是目标页面回调本地页面的方法,并带入参数
https://juejin.im/post/5be4f163f265da61483b1b08

#### 5. CORS

https://www.ruanyifeng.com/blog/2016/04/cors.html

origin 指定源，
withCredentials 打开之后可以发送cookie
#### 6. Get和Post的区别

https://www.zhihu.com/question/28586791

get发送一个tcp包，post发送两个tcp包。先发送header 然后发送数据。


### 安全相关

#### 1. XSS 跨站脚本攻击

#### 2. CSRF 跨站请求伪造



### 开发相关

#### 1. git rebase

- rebase操作可以把本地未push的分叉提交历史整理成直线
- rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比
- rebase一定要在未发布或未共享的分支上操作



### Node相关

#### 1. Express和Koa区别

#### 2. 中间件compose原理，手写





### 算法相关

#### 1. 杨辉三角，求第m行第n个数是多少？

- 递归

#### 2. 给定无序数组和一个数，求数组中项的和为这个数的所有情况

- [http://www.ryanshang.com/2019/05/02/两道有意思的面试题/](http://www.ryanshang.com/2019/05/02/两道有意思的面试题/)

#### 3. 数组的最大子序列和

#### 4. 给定两个升序数组和一个数，从这两个数组中各取一个数，和为给定的数




### 数据结构相关

#### 1. 遍历二叉树

#### 2. 深度遍历和广度遍历

```javascript
//1.深度优先遍历的递归写法
function deepTraversal(node){
  let nodes=[];
  if(node!=null){
      nodes.push[node];
      let childrens=node.children;
      for(let i=0;i<childrens.length;i++)
          deepTraversal(childrens[i]);
  }
  return nodes;
}

//2.深度优先遍历的非递归写法
function deepTraversal(node){
  let nodes=[];
  if(node!=null){
      let stack=[];//同来存放将来要访问的节点
      stack.push(node);
      while(stack.length!=0){
          let item=stack.pop();//正在访问的节点
          nodes.push(item);
          let childrens=item.children;
          for(let i=childrens.length-1;i>=0;i--)//将现在访问点的节点的子节点存入stack，供将来访问
              stack.push(childrens[i]);
      }
  }
  return nodes;
}

//3.广度优先遍历的递归写法
function wideTraversal(node){
  let nodes=[],i=0;
  if(node!=null){
      nodes.push(node);
      wideTraversal(node.nextElementSibling);
      node=nodes[i++];
      wideTraversal(node.firstElementChild);
  }
  return nodes;
}

//4.广度优先遍历的非递归写法
function wideTraversal(node){
  let nodes=[],i=0;
  while(node!=null){
      nodes.push(node);
      node=nodes[i++];
      let childrens=node.children;
      for(let i=0;i<childrens.length;i++){
          nodes.push(childrens[i]);
      }
  }
  return nodes;
}
```

#### 2. list转tree

#### 3. 单链表，奇数位升序，偶数位降序，如何让其升序排列？

- 拆分两个链表
- 偶数位链表倒序
- 合并两个链表



### 其他

#### 1. React生命周期

- [https://www.jianshu.com/p/514fe21b9914](https://www.jianshu.com/p/514fe21b9914)

#### 2. base64原理

- [https://www.colabug.com/4106075.html](https://www.colabug.com/4106075.html)


#### cookie和session区别

#### http状态码，301与302的区别，401与403的区别 
3-资源永久、临时重定向。 401 缺乏一些验证信息。403 服务器可以处理，但是访问无权限。
#### http2.0
1. 多路复用-就是可以同时发多个请求，还可以设置优先级。比如css和js可以优先下载
2. 头部压缩-借助静态字典表维护一些key-value，传输的时候传输字典值，比如method:GET映射成2，这样就能达到压缩头部的作用
3. 