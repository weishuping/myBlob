---
title: 数据过多表格加载优化和滚动优化
date: 2019-10-23 15:01:41
tags: 表格数据加载优化
---

问题：页面有400+条数据，且表格每行有约10个searchbox,每个searchbox有几百条下拉数据；若干input；若干span。
<!--more-->
分析：由于页面加载需要创建dom，并且需要绑定事件，在400条数据的时候页面卡死。
优化1：未点击之前，所有的均为span。当click的时候，才创建真正的输入元素。条件为当前行当前key。
问题：页面元素仍然有很多，需要懒加载。
优化2：优先加载大于1屏的数据，比如25条。
itemHeight: 每行高度
screenNumber: 一屏多少条数据
totalLength: 总数据长度
currentLength: 当前加载数据的长度
当前可视范围内的第一行数据序号 = scrollTop / itemHeight
优化点：控制滚动的频率。当前可视区域第一行数 + 整屏个数 = end; 页面已加载currentLength - end < 5条，开始重新加载。
优化3：使用节流，控制触发频率。
核心代码如下 
```
return function (){
        let top = event.target.scrollTop;
        let start = Math.floor(top / 40) ;
        let currentLength = that.planData.length;// 可视区域数据
        let totalLength = that.budgetData.length;// 原始数据
        // 控制滚动的频率。当前可视区域第一行数 + 整屏个数 = end; 页面已加载currentLength - end < 5条。开始重新加载。
        let end = start + that.stepItemPage;
        if (end < totalLength && currentLength - end < 5) {
        // 如果滑动不足，加载两屏数据出来。
            let crashRows = Math.ceil(that.stepItemPage * 2);
            console.log('down', start, start + crashRows, totalLength, top, that.scrollTop);
            let nextData = [];
            // 增加上面高度 才有scroll
            for (let index = 0; index < start; index++) {
                nextData.push({order: index, hasTd: true});
            }
            nextData = nextData.concat(that.budgetData.slice(start, start + crashRows));
            that.planData = nextData;
            that.scrollTop = top;
        }
    };
```
但是仍然存在问题：向上滑动有空白情况。需要考虑多种情况和临界值
版本二：
```

    let el = document.querySelector('.body-wrapper');
    // if (el && el.offsetHeight) {
    //     this.stepItemPage = Math.ceil(el.offsetHeight / ITEM_HEIGHT);// 每屏幕行数
    // }
    let top = event.target.scrollTop;
    if (this.top === top) {
        return false;
    }
    this.top = top;
    let wrapperHeight = el.clientHeight;
    let height = top - wrapperHeight;
    let start = Math.floor(height / ITEM_HEIGHT) ;
    start = start >= 0 ? start : 0;
    if (this.start === start) {
        return false;
    }
    // this.$emit('update:pageLoading', true);
    let offset = Math.abs(start - this.start);// 差值
    let screenOffset = wrapperHeight / ITEM_HEIGHT;// 当前屏幕个数
    let crashRows = Math.ceil(this.stepItemPage * 3);// 如果滑动不足，加载3屏数据出来。
    let totalLength = this.budgetData.length;// 原始数据
    let end = start + crashRows;
    end = end >= totalLength? totalLength -1 : end;
    console.log(this.start, "start", start, "old start", this.start, '起始差值', screenOffset, "结束",end);
    if ((offset - screenOffset > -3 || start === 0 || end === totalLength -1)) {
        let nextData = [];
        // 撑开上面高度，实际数为空 才有scroll
        for (let index = 0; index < start; index++) {
            nextData.push({order: index, hasTd: true});
        }
        // 加载大约3屏数据量
        nextData = nextData.concat(this.budgetData.slice(start, end + 1));
        this.planData = nextData;
        this.start = start;
    }
```
版本三

给table加translate(0, start * 行高),也就是说看到的滚动条上方均是盒子撑开的高度，而不是去真正的渲染dom和样式。
```
 dealScrollEvent(event) {
    let el = document.querySelector('.body-wrapper');
    let top = event.target.scrollTop;
    if (this.top === top) {
        return false;
    }
    // 向上滑动必须加loading
    if (top < this.top) {
        this.$emit('update:pageLoading', true);
    }
    let wrapperHeight = el.clientHeight * 1.2; // 相当于在外层包裹一层
    let height = top - wrapperHeight;
    let start = Math.floor(height / ITEM_HEIGHT) ;
    start = start >= 0 ? start : 0;
    if (this.start === start) {
        this.top = top;
        this.$emit('update:pageLoading', false);
        return false;
    } else {
        this.top = top;
    }
    let offset = Math.abs(start - this.start);// 差值
    let screenOffset = wrapperHeight / ITEM_HEIGHT;// 包裹层当前屏幕个数
    let crashRows = Math.floor((1 + (2 * 1)) * screenOffset);// 如果滑动不足，上下1.2屏数据出来。
    let totalLength = this.budgetData.length;// 原始数据
    let end = start + crashRows;
    end = end >= totalLength? totalLength -1 : end;
    console.log(this.start, "start", start, "old start", this.start, '起始差值', screenOffset, "结束",end);
    if ((offset > screenOffset  || start === 0 || end === totalLength -1)) {
        if (!this.pageLoading) {
            this.$emit('update:pageLoading', true);
        }
        let nextData = [];
        // 撑开上面高度，实际数为空 才有scroll
        // for (let index = 0; index < start; index++) {
        //     nextData.push({order: index, hasTd: true});
        // }
        // 优化3：上述有副作用，渲染无用的dom 导致页面卡顿
        document.querySelector('.body-wrapper').querySelector('table').style.transform = `translate(0, ${(start * ITEM_HEIGHT)}px)`;
        document.querySelector('.body-fixed-wrapper').querySelector('table').style.transform = `translate(0, ${(start * ITEM_HEIGHT)}px)`;
        this.planData = nextData.concat(this.budgetData.slice(start, end));
        this.start = start;
    }
    setTimeout(() => {
        this.$emit('update:pageLoading', false);
    }, 1000);
}
```



