---
title: flex
date: 2019-10-23 15:01:41
tags: 表格数据加载优化
---

问题：
页面有400+条数据，且表格每行有约10个searchbox,每个searchbox有几百条下拉数据；若干input；若干span。
分析：由于页面加载需要创建dom，并且需要绑定事件，在400条数据的时候页面卡死。
优化1：
未点击之前，所有的均为span。当click的时候，才创建真正的输入元素。
问题：
页面元素仍然有很多，需要懒加载。
优化2：
优先加载大于1屏的数据，比如25条。
itemHeight: 每行高度
screenNumber: 一屏多少条数据
totalLength: 总数据长度
currentLength: 当前加载数据的长度
当前可视范围内的第一行数据序号 = scrollTop / itemHeight
优化点：控制滚动的频率。当前可视区域第一行数 + 整屏个数 = end; 页面已加载currentLength - end < 5条，开始重新加载。
```
return function (){
            let top = event.target.scrollTop;
            let start = Math.floor(top / 40) ;
            let currentLength = that.planData.length;// 可视区域数据
            let totalLength = that.budgetData.length;// 原始数据
            // 控制滚动的频率。当前可视区域第一行数 + 整屏个数 = end; 页面已加载currentLength - end < 5条。开始重新加载。
            let end = start + that.stepItemPage;
            if (end < totalLength && currentLength - end < 5) {
            // 如果滑动不足，加载两屏数据出来。
                let crashRows = Math.ceil(that.stepItemPage * 2);
                console.log('down', start, start + crashRows, totalLength, top, that.scrollTop);
                let nextData = [];
                // 增加上面高度 才有scroll
                for (let index = 0; index < start; index++) {
                    nextData.push({order: index, hasTd: true});
                }
                nextData = nextData.concat(that.budgetData.slice(start, start + crashRows));
                that.planData = nextData;
                that.scrollTop = top;
            }
        };
```


